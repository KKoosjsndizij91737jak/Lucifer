
local bot = getBot()
local inventory = getBot():getInventory()
local printed = getBot():getLog()

while bot.status ~= BotStatus.online do
    bot:connect()
    sleep(delayreconnect * 1000)
end

local strGenerate = ''
for i = 1,worldLetter do
    strGenerate = strGenerate..string.char(math.random(97,122))
end

while not bot:isInWorld() do
    bot:warp(strGenerate)
    sleep(delaywarp * 1000)
end

for i, bots in pairs(getBots()) do
    if bots.name:upper() == getLocal().name:upper() then
        pcallBot = i
    end
end

local onTile = {}
local tutorial = {}
local botTile = {} 
local initialize = {} 
local onLeveling = {}
local onFarmList = {}
local plantTable = {}
local indexPnb = {}
local onBotBackup = {}
local onMessage = {}
local initFreshWorld = {} 
local freshId = {}
reversed = 1
pointData = block + 1
identity = 5
indexMessage = 1 
strFormatted = 'None'
increment = 1 * 2 * 3
local customizable = {
    variableSeeds = 0,
    variablePacks = 0,
    variableEvents = 0,
    indexPlant = 1,
    indexPacks = 1,
    indexSeeds = 1,
    indexEvents = 1,
    indexBackups = 1,
    indexLeveling = 1,
    indexFresh = 1,
    indexCreating = 1,
    changeWorld = 1, 
    formatTime = os.time(),
    seedsX = dropseedX - 1,
    seedsY = dropseedY - 1,
    packsX = droppackX - 1,
    packsY = droppackY - 1,
    eventsX = dropeventX - 1,
    eventsY = dropeventY - 1,
    positionX = customBreakX - 1,
    positionY = customBreakY - 1,
    jammerX = dropJammerX - 1,
    jammerY = dropJammerY - 1,
    lock = {242 , 9640 , 202 , 204 , 206 , 1796 , 4994 , 7188 , 2408 , 2950 , 4428 , 4802 , 5814 , 5260 , 5980 , 8470 , 10410 , 11550 , 11586 },
    notTrashItems = {18, 32, 6336, 9640, block,pointData,idblockleveling,idblockleveling+1}
}

bot.auto_reconnect = false
bot.auto_collect = false
bot.legit_mode = false
bot.move_range = moveRange
bot.move_interval = moveInterval
bot.collect_range  = range
if ignoregems then
    bot.ignore_gems = true
end

for idx, val in pairs(packList) do
    table.insert(customizable.notTrashItems,val)
end
for k, pack in pairs(eventList) do
    table.insert(customizable.notTrashItems,pack)
end
for i =  1,indexMessage do
    table.insert(onMessage,messageidbotinfo[math.floor((pcallBot - 1) * indexMessage + i)])
end
for i = math.floor(pnbtile/2),1,-1 do
    i = i * -1
    table.insert(onTile,i)
end
for i = 0, math.ceil(pnbtile/2) - 1 do
    table.insert(onTile,i)
end
for x = math.floor(identity/2),1,-1 do
    x = x * -1
    table.insert(botTile,x)
end
for x = 0, math.ceil(identity/2) - 1 do
    table.insert(botTile,x)
end

customizable.itemFloat = function(id)
    return bot:getWorld().growscan:getObjects()[id] or 0
end

customizable.randomLetter = function(length)
    local alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    local withnum = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    local generate = ''
    for i = 1,length do
        local random = math.random(1,#alphabet)
        local randomnumber = math.random(1,#withnum)
        local acakalpa = string.sub(alphabet,random,random)
        local acaknomor = string.sub(withnum,randomnumber,randomnumber)
        if withnumber then
            generate = generate..acaknomor
        else
            generate = generate..acakalpa
        end
    end
    return generate
end

customizable.notifications = function(desc)
    messageBox = MessageBox.new()
    messageBox.title = 'Caramoy Syndicate'
    messageBox.description = desc
    messageBox:send()
end

customizable.setSkin = function()
    if changeSkin then
        bot:setSkin(math.random(1, 6))
        sleep(1000)
    end    
end

customizable.itemcheck = function(tbl, int)
    for _,num in pairs(tbl) do
        if num == int then
            return true
        end
    end
    return false
end

customizable.recycles = function()
    for _,item in pairs(inventory:getItems()) do
        if not customizable.itemcheck(customizable.notTrashItems,item.id) and not customizable.itemcheck(whitelistItem,item.id) then
            bot:trash(item.id, inventory:getItemCount(item.id))
            sleep(1000)
        end
    end
end

customizable.scanBlock = function(id)
    local count = 0
    for _, tile in pairs(bot:getWorld():getTiles()) do
        if tile.fg == id then
            count = count + 1
        end
    end
    return count
end

customizable.isPlanted = function(ex,ye)
    includes = getTile(ex, ye+1)
    classType = getInfo(includes.fg).collision_type
    return getTile(ex,ye).fg == 0 and (classType ~= 0 and classType <= 3) and includes.fg ~= 0 and bot:getWorld():hasAccess(ex,ye)
end 

customizable.isHarvested = function(ex,ye,itm)
    return getTile(ex,ye).fg == itm and getTile(ex,ye):canHarvest() and bot:getWorld():hasAccess(ex,ye) > 0 and getTile(ex,ye).flags < 4096
end

customizable.detectPlant = function(static,id,item)
    tileA, tileB, tileC, tileD = 99, 0, -1, 0
    local function isTrue(ex,ye)
        if customizable.detectTile() then
            return customizable.isPlanted(ex,ye) and ye ~= 0
        else
            return customizable.isPlanted(ex,ye)
        end
    end
    if bot:isInWorld() then
        for y = -1 , 53 do
            for x = tileA, tileB, tileC do
                if inventory:getItemCount(item) > 0 then
                    if isTrue(x,y) then
                        while not bot:isInTile(x,y) do
                            bot:findPath(x,y)
                            customizable.reconnect(static,id,x,y)
                        end
                        for i = 1, 10 do
                            if customizable.isPlanted(x,y) then
                                bot:place(x,y,item)
                                sleep(delayplant)
                                customizable.reconnect(static,id,x,y)
                            else
                                break
                            end
                        end
                    end
                else
                    break
                end
            end
        end
    end
end

customizable.detectTable = function(items,amt)
    for _, init in pairs(items) do
        if inventory:getItemCount(init) >= amt then
            return true
        end
    end
    return false
end

customizable.tableFormatted = function(time)
    if strFormatted == 'None' then
        strFormatted = ''
    end
    strFormatted = strFormatted..time..'\n'
end 

customizable.setAuth = function()
    if withproxy then
        getProxyManager():setLimit(botperproxy)
        for _, val in pairs(proxyList) do
            getProxyManager():addProxy(val)
        end
    end
end

customizable.hookOnTutorial = function(var, netid)
    if var:get(0):getString() == 'OnDialogRequest' then
        if var:get(1):getString():find('myWorldsUiTab') then
            table.insert(tutorial,var:get(1):getString():match('add_button|(%w+)|'))
        end
    end
end

customizable.split = function(str, ptr)
    if not ptr then 
        ptr = '%s'
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string) 
    end
    return tbl
end

customizable.detectTile = function()
    for x = 0, 99 do
        if getTile(x,1).flags ~= 0 then
            return true
        end
    end
    return false
end 

customizable.activity = function(ex,ye,str)
    return (str == 'punch' and (getTile(ex,ye).fg ~= 0 or getTile(ex,ye).bg ~= 0 and bot:getWorld():hasAccess(ex,ye) ~= 0 and not getTile(ex,ye):hasFlag(4096)) or str == 'place' and (getTile(ex,ye).fg == 0 or getTile(ex,ye).bg == 0 and bot:getWorld():hasAccess(ex,ye) ~= 0 and not getTile(ex,ye):hasFlag(4096)))
end

customizable.botDoing = function(x,y,str)
    for _, num in pairs(onTile) do
        tileType = bot:getWorld():hasAccess(x + 1, y + num) ~= 0 and not getTile(x + 1, y + num):hasFlag(4096)
        if (str == 'place' and (getTile(x + 1, y + num).fg == 0 and getTile(x + 1, y + num).bg == 0 and tileType) or str == 'punch' and (getTile(x + 1, y + num).fg ~= 0 or getTile(x + 1, y + num).bg ~= 0 and tileType)) then
            return true
        end
    end
    return false
end

customizable.botActivites = function(x,y,str,seed,num)
    for _,idx in pairs(botTile) do
        tileType = bot:getWorld():hasAccess(x + idx,y + str) ~= 0 and not getTile(x + idx,y + str):hasFlag(4096)
        if (num == 'harvest' and (getTile(x + idx,y + str).fg == seed and getTile(x + idx,y + str):canHarvest() and tileType) or num == 'plant' and (getTile(x + idx,y + str).fg == 0 and tileType)) then
            return true
        end
    end
    return false
end

customizable.tileDetect = function()
    for _, value in pairs(customizable.lock) do
        for _, tile in pairs(bot:getWorld():getTiles()) do
            if tile.fg == value then
                return true
            end
        end
    end
    return false
end

customizable.levelBot = function()
    return (leveling and (bot.level >= setminlvl) or not leveling and (bot.level > 1))
end

customizable.detectInventory = function(str,info,static,item,log)
    if inventory:getItemCount(item) >= amountBlock and inventory:getItemCount(pointData) < amountseed and customizable.levelBot() then 
        customizable.onPnb(str,info,static,item)
        printed:append(log)
        while not bot:isInWorld(info) do
            customizable.warp(info,static)
        end
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif inventory:getItemCount(idItemSupport) == 0 and wearingItemSupport then
        bot.auto_collect = false
        printed:append('Wearing item support')
        customizable.localInfo('Wearing item support')
        while inventory:getItemCount(idItemSupport) == 0 do
            customizable.wearingItem(worlditemtowear,idItemSupport,keepItemSupport,'Item support')
        end
        printed:append(log)
        customizable.warp(info,static)
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif customizable.detectTable(eventList,amountEvent) then
        bot.auto_collect = false
        customizable.onEvent(info)
        printed:append(log)
        customizable.warp(info,static)
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif inventory:getItemCount(item+1) >= amountseed then
        bot.auto_collect = false
        if autoPlant and str ~= 'leveling' then
            customizable.plant(info,static,item+1)
            if inventory:getItemCount(item+1) >= amountseed / 2 then
                customizable.autoPlantEnabled()
            end
        else
            if dontplant and str ~= 'leveling' then
                customizable.onSeed(item+1)
            else
                while not bot:isInWorld(info) do
                    customizable.warp(info,static)
                end
                customizable.plant(info,static,item+1)
                if inventory:getItemCount(item+1) >= amountseed / 2 then
                    customizable.onSeed(item+1)
                end
            end
        end
        printed:append(log)
        while not bot:isInWorld(info) do
            customizable.warp(info,static)
        end
        customizable.localInfo(log)
        bot.auto_collect = true
    elseif bot.gem_count >= mingems and buypack then
        bot.auto_collect = false
        customizable.buying()
        customizable.onPack()
        customizable.warp(info,static)
        bot.auto_collect = true
    end
end

customizable.detectPlayer = function()
    for _, player in pairs(getPlayers()) do
        if player.name ~= getBots()[pcallBot].name and player.name ~= whitelist then
            return true
        end 
    end
    return false
end

customizable.scanningFlags = function(id)
    for _, tile in pairs(bot:getWorld():getTiles()) do
        if tile:hasFlag(id) then
            return true
        end
    end
    return false
end

customizable.flagsCheck = function(id)
    local count = 0
    for _, tile in pairs(bot:getWorld():getTiles()) do
        if tile:hasFlag(id) then
            count = count + 1
        end
    end
    return count
end

customizable.cleaning = function(str,init,id)
    if str == 'toxic' then
        while customizable.scanningTile(778) do
            for _, tile in pairs(bot:getWorld():getTiles()) do
                if tile.fg == 778 then
                    local founder = false
                    local x, y = tile.x, tile.y
                    local tiled = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } }
                    if bot:findPath(x + tiled[1][1], y + tiled[1][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[1][1], y + tiled[1][2])
                    elseif bot:findPath(x + tiled[2][1], y + tiled[2][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[2][1], y + tiled[2][2])
                    elseif bot:findPath(x + tiled[3][1], y + tiled[3][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[3][1], y + tiled[3][2])
                    elseif bot:findPath(x + tiled[4][1], y + tiled[4][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[4][1], y + tiled[4][2])
                    end
                    founder = true
                end
            end
        end
    elseif str == 'burn' then
        while customizable.scanningFlags(4096) do
            ::back::
            local count = 0
            for _, tile in pairs(bot:getWorld():getTiles()) do
                if tile:hasFlag(4096) then
                    local founder = false
                    local x, y = tile.x, tile.y
                    local tiled = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } }
                    if bot:findPath(x + tiled[1][1], y + tiled[1][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[1][1], y + tiled[1][2])
                    elseif bot:findPath(x + tiled[2][1], y + tiled[2][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[2][1], y + tiled[2][2])
                    elseif bot:findPath(x + tiled[3][1], y + tiled[3][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[3][1], y + tiled[3][2])
                    elseif bot:findPath(x + tiled[4][1], y + tiled[4][2]) and not founder then
                        sleep(delaypunch)
                        bot:hit(tile.x, tile.y)
                        customizable.reconnect(init,id,x + tiled[4][1], y + tiled[4][2])
                    end
                    founder = true
                    count = count + 1
                    if count == 50 then
                        count = 0
                        goto back
                    end
                end
            end
        end
        bot.auto_collect = false
        printed:append('Storing fire hose')
        customizable.localInfo('Storing fire hose')
        customizable.aboutHose('drop',init,id)
        customizable.warp(init,id)
    end
end

customizable.scanningTile = function(id)
    for _, tile in pairs(bot:getWorld():getTiles()) do
        if tile.fg == id then
            return true
        end
    end
    return false
end

customizable.writeFile = function(info,text)
    local file = io.open(info..'.txt','a')
    file:write(text..'\n')
    file:close()
end

local function readFile(fileContents, fileNames)
    local allFilesContents = {}
    for i, fileName in ipairs(fileNames) do
        local file = io.open(fileName, 'r')
        if not file then
            customizable.notifications('Fail to open file '..fileName..'.')
            return nil
        else
            local fileContent = {}
            for line in file:lines() do
                table.insert(fileContent, line)
            end
            file:close()
            table.insert(fileContents, fileContent)
        end
    end
    return fileContents
end

if autoSwitch then
    local switchTable = {}
    local files = {switchFile}
    local text = readFile({},files)
    if text then
        for i, fileContent in ipairs(text) do
            for _, line in ipairs(fileContent) do
                table.insert(switchTable,line)
            end
        end
    end
    local onIndex =  pcallBot - 1
    local onSplit = #switchTable / #getBots()
    local onStart = math.floor(onIndex * onSplit + 1)
    local onStop = math.floor(onIndex + 1) * onSplit
    for i = onStart, onStop do
        table.insert(onBotBackup,switchTable[i])
    end
end

if pnbother and useCustomPnb then
    local pnbTable = {}
    local files = {PnbFile}
    local text = readFile({},files)
    if text then
        for i, fileContent in ipairs(text) do
            for _, line in ipairs(fileContent) do
                table.insert(pnbTable,line)
            end
        end
    end
    local onIndex =  pcallBot - 1
    local onSplit = #pnbTable / #getBots()
    local onStart = math.floor(onIndex * onSplit + 1)
    local onStop = math.floor(onIndex + 1) * onSplit
    for i = onStart, onStop do
        table.insert(indexPnb,pnbTable[i])
    end
end

if autoPlant then
    local onPlant = {}
    local files = {worldPlantFile}
    local text = readFile({},files)
    if text then
        for i, fileContent in ipairs(text) do
            for _, line in ipairs(fileContent) do
                table.insert(onPlant,line)
            end
        end
    end
    local onIndex =  pcallBot - 1
    local onSplit = #onPlant / #getBots()
    local onStart = math.floor(onIndex * onSplit + 1)
    local onStop = math.floor(onIndex + 1) * onSplit
    for i = onStart, onStop do
        table.insert(plantTable,onPlant[i])
    end
end

if leveling then
    local levelingTable = {}
    local files = {worldLeveling}
    local text = readFile({},files)
    if text then
        for i, fileContent in ipairs(text) do
            for _, line in ipairs(fileContent) do
                table.insert(levelingTable,line)
            end
        end
    end
    local onIndex =  pcallBot - 1
    local onSplit = #levelingTable / #getBots()
    local onStart = math.floor(onIndex * onSplit + 1)
    local onStop = math.floor(onIndex + 1) * onSplit
    for i = onStart, onStop do
        table.insert(onLeveling,levelingTable[i])
    end
end

if takeBackJammer then
    local jammerTable = {}
    local files = {'FreshWorld.txt'}
    local text = readFile({},files)
    if text then
        for i, fileContent in ipairs(text) do
            for _, line in ipairs(fileContent) do
                table.insert(jammerTable,line)
            end
        end
    end
    for i = 1, #jammerTable do
        table.insert(freshId,jammerTable[i])
    end
end

local farmTable = {}
local files = {farmFile}
local text = readFile({},files)
if text then
    for i, fileContent in ipairs(text) do
        for _, line in ipairs(fileContent) do
            table.insert(farmTable,line)
        end
    end
end
local onIndex =  pcallBot - 1
local onSplit = #farmTable / #getBots()
local onStart = math.floor(onIndex * onSplit + 1)
local onStop = math.floor(onIndex + 1) * onSplit
for i = onStart, onStop do
    table.insert(onFarmList,farmTable[i])
end

customizable.getBotWords = function()
    if sayingrandomwords then
        local random = {
            'Cuma senyuman doang, udah bikin gemes.','Bentar lagi uda jarang ni lu nongkrong di sini.','Kita ngapain sih, ikut-ikutan heboh?','Gue tuh selalu berusaha baik, tapi gimana ya.','Gak usah diambil pusing, santai aja dulu.','Jangan sok asik, tuh keliatan banget.','Santai aja dulu, gak usah tegang.','Jangan bawa drama-dramaan, capek.',
            'Gak usah dibawa serius, nanti malah stress.','Gue tuh kalem, gak usah ribut.','Lagi asik nongkrong, ada yang ngomongin.','Buat apa pake jaim-jaim, santai aja.','Lagi asik handler game, tiba-tiba ada yang gangguin.','Gak usah sok asik, keliatan banget.','Nggak perlu pake baper, gak ada gunanya.','Gue gak peduliin, tinggalin aja.','Nih, jualan makanan enak banget di sini.',
            'Santai aja dulu, gak usah terlalu serius.','Nggak usah diambil pusing, biar enak.','Hati-hati, banyak orang munafik.','Lagi pada heboh semua, bikin geger.','Gak usah pake jaim-jaim, santai aja.','Lagi dengerin lagu enak, bawaannya pengen joget.','Nih, lagi pada rame-rame di tempat baru.','Gue tuh kalem, gak perlu ribut.','Kondisi lagi kacau, gak karuan banget.',
            'Udah capek-capek ngomong, gak dengerin juga.','Asik banget nih, liburan seru.','Gak usah sok asik, keliatan banget.','Bentar lagi weekend, pasti seru banget nih.','Cuma bisa doa aja, gimana lagi.','Lagi asik handler, ada yang gangguin.','Gue gak peduliin, tinggalin aja.','Lagi mikirin, gak usah bener-bener serius.','Jangan dibawa serius, nanti malah stress.'
        }
        local idx = math.random(1, #random)
        local words = random[idx]
        bot:say(words)
        sleep(1000)
    end
end

customizable.customTile = function(world,door)
    botX, botY = bot.x, bot.y
    if botX == 1 then
        botX = botX + 2
        while not bot:isInTile(botX,botY) do
            bot:findPath(botX,botY)
            sleep(100)
            customizable.reconnect(world,door)
        end
    elseif botX == 2 then
        botX = botX + 1
        while not bot:isInTile(botX,botY) do
            bot:findPath(botX,botY)
            sleep(100)
            customizable.reconnect(world,door)
        end
    elseif botX == 0 then
        botX = botX + 3
        while not bot:isInTile(botX,botY) do
            bot:findPath(botX,botY)
            sleep(100)
            customizable.reconnect(world,door)
        end
    end
end

customizable.customPnb = function(init,id,concate,x,y)
    while inventory:getItemCount(98) > 0 and not inventory:getItem(98).isActive do
        bot:wear(98)
        sleep(1000)
    end
    bot.auto_collect = true
    printed:append('Pnb')
    customizable.localInfo('Pnb')
    while not bot:isInTile(x,y) do
        bot:findPath(x,y)
        sleep(500)
        customizable.reconnect(init,id,x,y)
    end
    customizable.setSkin()
    customizable.getBotWords()
    botX, botY = bot.x, bot.y
    while inventory:getItemCount(concate) >= pnbtile do
        if pnbtile == 1 then
            if customizable.activity(botX+ 1,botY,'place') then
                bot:place(botX+ 1,botY,concate)
                sleep(delayplace)
                customizable.reconnect(init,id,x,y)
            end
            if customizable.activity(botX + 1,botY,'punch') then
                bot:hit(botX + 1,botY)
                sleep(delaypunch)
                customizable.reconnect(init,id,x,y)
            end
        else
            while customizable.botDoing(botX,botY,'place') do
                for _,i in pairs(onTile) do
                    if customizable.activity(botX+1,botY+i,'place') then
                        bot:place(botX+1,botY+i,concate)
                        sleep(delayplace)
                        customizable.reconnect(init,id,x,y)
                    end
                end
            end
            while customizable.botDoing(botX,botY,'punch') do
                for _,i in pairs(onTile) do
                    if customizable.activity(botX+1,botY+i,'punch') then
                        bot:hit(botX+1,botY+i)
                        sleep(delaypunch)
                        customizable.reconnect(init,id,x,y)
                    end
                end
            end
        end
        if customizable.detectPlayer() and whitelist ~= 'x' then
            customizable.textInfo('','Random people joining world : '..getWorld().name..', Bot are disconnected and sleeping for '..delaySleep..' seconds')
            if exitWhenPeopleJoin then
                while bot:isInWorld() and bot.status == BotStatus.online do
                    bot:leaveWorld()
                    sleep(5000)
                end
                sleep(delaySleep * 1000)
                customizable.reconnect(init,id,x,y)
            else
                while bot.status ~= BotStatus.offline do
                    bot:disconnect()
                    sleep(5000)
                end
                sleep(delaySleep * 1000)
                customizable.reconnect(init,id,x,y)
            end
        end
        if inventory:getItemCount(concate+1) >= amountseed then
            break
        elseif bot.gem_count >= mingems and buypack then
            break
        end
    end
    if autoSwitch and bot.level >= switchOnLevel then
        bot.auto_collect = false
        if inventory:getItemCount(concate+1) > 0 then
            customizable.onSeed(concate+1)
        end
        customizable.onBackup()
        customizable.mainScript()
    end
    customizable.recycles()
end

customizable.pattern = function(str,world,id,seed)
    botX, botY = bot.x, bot.y
    customizable.customTile(world,id)
    local function harvestingTree(num,ptr)
        local tileY = 0
        if num == 'up' then
            tileY = botY - 2
        elseif num == 'mid' then
            tileY = botY
        elseif num == 'down' then
            tileY = botY + 2
        end
        count = 0
        while customizable.botActivites(botX,botY,ptr,seed,'harvest') do
            for _,i in pairs(botTile) do
                if customizable.isHarvested(botX + i,tileY,seed) then
                    bot:hit(botX + i,tileY)
                    sleep(delayharvest)
                    customizable.reconnect(world,id,botX,botY)
                end
            end
            count = count + 1
            if count == 15 then
                count = 0
                break
            end
        end
    end
    local function plantingTree(num,ptr)
        local tileY = 0
        if num == 'up' then
            tileY = botY - 2
        elseif num == 'mid' then
            tileY = botY
        elseif num == 'down' then
            tileY = botY + 2
        end
        count = 0
        while customizable.botActivites(botX,botY,ptr,0,'plant') do
            for _,i in pairs(botTile) do
                if customizable.isPlanted(botX+i,tileY) then
                    bot:place(botX+i,tileY,seed)
                    sleep(delayplant)
                    customizable.reconnect(world,id,botX,botY)
                end
            end
            count = count + 1
            if count == 5 then
                count = 0
                break
            end
        end
    end
    if str == 'harvest' then
        harvestingTree('up',-2)
        harvestingTree('mid',0)
        harvestingTree('down',2)
    elseif str == 'plant' then
        plantingTree('up',-2)
        plantingTree('mid',0)
        plantingTree('down',2)
    end
end

customizable.initBot = function()
    if bot.status == BotStatus.online then
        return 'Online'
    elseif bot.status == BotStatus.account_banned  then
        return 'Suspended'
    elseif bot.status == BotStatus.error_connecting  then
        return 'Ercon'
    elseif bot.status == BotStatus.maintenance then
        return 'Maintenance'
    elseif bot.status == BotStatus.changing_subserver then
        return 'Changing Subserver'
    elseif bot.status == BotStatus.location_banned then
        return 'Location Banned'
    else
        return 'Disconnect'
    end
end

customizable.globalInfo = function(values)
    str = ''
    if values == 'switch' then
        if autoSwitch then
            for i = 1, #onBotBackup do
                local world = customizable.split(onBotBackup[i],'[^|]+')[1]
                str = str..'\n||'..string.upper(world)..'|| ('..(initialize[world] or '?')..')'
            end
        else
            return 'Not using switch'
        end
    elseif values == 'seed' then
        if not autoPlant then
            for i = 1, #worldseed do
                local world = customizable.split(worldseed[i],'[^|]+')[1]
                str = str..'\n||'..string.upper(world)..'|| : '..(initialize[world] or '?')..''
            end
        else
            return 'Undefined (Auto plant is enable)'
        end
    elseif values == 'pack' then
        for i = 1, #worldpack do
            local world = customizable.split(worldpack[i],'[^|]+')[1]
            str = str..'\n||'..string.upper(world)..'|| : '..(initialize[world] or '?')..''
        end
    elseif values == 'event' then
        for i = 1, #worldevent do
            local world = customizable.split(worldevent[i],'[^|]+')[1]
            str = str..'\n||'..string.upper(world)..'|| '..(initialize[world] or '?')..''
        end
    end
    return str
end

customizable.initializeBots = function(text)
    if webhookstatuslink ~= 'x'  then
        local webhook = Webhook.new(webhookstatuslink)
        webhook.content = '@everyone'
        webhook.embed1.use = true
        webhook.embed1:addField('',text,false)
        webhook.embed1.footer.text = 'Webhook Status, sent at : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
        webhook:send()
    end
end

customizable.textInfo = function(str,alphabet)
    printed:append(alphabet)
    customizable.initializeBots('('..string.upper(bot.name)..') '..alphabet)
    if str == 'stop' then
        customizable.notifications(string.upper(bot.name)..' : '..alphabet)
        error(alphabet)
    end
end

customizable.localInfo = function(info)
	if linkbotinfo ~= 'x' then 
        for idx , val in ipairs(onMessage) do
            realtime = os.time() - customizable.formatTime
            webhook = Webhook.new(linkbotinfo)
            webhook.embed1.use = true
            webhook.embed2.use = true
            webhook.embed1.title = 'Caramoy Syndicate [https://discord.com/invite/fTTKW8vvuq]'
            webhook.embed1.color = math.random(111111,999999)
            webhook.embed1:addField('','```Botname : ['..bot.level..']'..string.upper(bot.name)..'\nTask : '..info..'\nGems : '..bot.gem_count..'\nCurrent : '..string.upper(getWorld().name)..'\nStatus : '..customizable.initBot()..'\nRuntime : '..math.floor(realtime/86400)..' Days '..math.floor(realtime%86400/3600)..' Hours '..math.floor(realtime%86400%3600/60)..' Minutes```',false)
            webhook.embed1:addField('Seed',customizable.globalInfo('seed'),true)
            webhook.embed1:addField('Pack',customizable.globalInfo('pack'),true)
            webhook.embed1:addField('Event',customizable.globalInfo('event'),true)
            webhook.embed2:addField('Farm Estimates',strFormatted,true)
            webhook.embed2:addField('Bot Switch',customizable.globalInfo('switch'),true)
            webhook.embed2.footer.text = '[Lucifer] : Rotation Script\nLast update : '..(os.date('!%a %b %d, %Y at %I:%M %p', os.time() + 7 * 60 * 60))..''
            webhook:edit(val)
        end
    end
end

customizable.usingRestCustom = function()
    for _,value in pairs(timeRest) do
        if value == (os.date("%H:%M",os.time() + 0 * 60 * 60)) then
            clock = value
            return true
        end
    end
    return false 
end

customizable.reconnect = function(world,id,x,y)
    if botRest then
        if useCustomTime and customizable.usingRestCustom() then
            customizable.localInfo('Resting')
            customizable.textInfo('','Now at : '..clock..', Bot resting for '..delayRest..' minutes')
            if disconnectOnRest then
                while bot.status ~= BotStatus.offline do
                    bot:disconnect()
                    sleep(5000)
                end
            else
                while bot:isInWorld() and bot.status == BotStatus.online do
                    bot:leaveWorld()
                    sleep(5000)
                end
            end
            sleep(delayRest * 60000)
        else
            local timed = os.time() - customizable.formatTime
            local loggoning = math.floor(timed/60)
            if loggoning >= botRestInterval then
                customizable.formatTime = os.time()
                customizable.textInfo('','Bot doing rotation for '..botRestInterval..' minutes, resting '..botRestTime..' minutes')
                customizable.localInfo('Resting')
                if disconnectOnRest then
                    while bot.status ~= BotStatus.offline do
                        bot:disconnect()
                        sleep(5000)
                    end
                else
                    while bot:isInWorld() and bot.status == BotStatus.online do
                        bot:leaveWorld()
                        sleep(5000)
                    end
                end
                sleep(botRestTime * 60000)
            end
        end
    end
    if not bot:isInWorld(world:upper()) or bot.status ~= BotStatus.online then
        customizable.textInfo('','status is '..customizable.initBot()..', Current : '..getWorld().name..'')
        while bot.status ~= BotStatus.online do
            bot:connect()
            if bot.status == BotStatus.account_banned then
                customizable.textInfo('stop','status is '..customizable.initBot()..'')
            else
                if bot.status == BotStatus.maintenance then
                    customizable.textInfo('','Server is maintenance, Sleeping for '..delaymaintenance..' minutes')
                    sleep(delaymaintenance * 60000)
                else
                    sleep(delayreconnect * 1000)
                end
            end
        end
        while not bot:isInWorld(world:upper()) do
            bot:warp(world:upper())
            sleep(delaywarp * 1000)
        end
        if id ~= '' then
            while getTile(bot.x,bot.y).fg == 6 do
                bot:warp(world:upper(),id:upper())
                sleep(delaywarp * 1000)
            end
        end
        if x and y then
            while bot.x ~= x or bot.y ~= y do
                bot:findPath(x,y)
                sleep(150)
            end
        end
        customizable.textInfo('','status is '..customizable.initBot()..', Current : '..getWorld().name..'')
    end
end

customizable.buying = function()
    printed:append('Buying packs')
    customizable.localInfo('Buying Pack')
    if upbackpack then
        if inventory.slotcount < 36 then
            printed:append(pcallBot..'. Upgrading backpacks')
            repeat
                bot:sendPacket(2,'action|buy\nitem|upgrade_backpack')
                sleep(1000)
            until inventory.slotcount >= 36
        end
    end
    while bot.gem_count >= pricepack do
        bot:sendPacket(2,'action|buy\nitem|'..debug)
        sleep(1000)
        if customizable.detectTable(packList,200) then
            break
        end
    end
end

customizable.warp = function(world,door)
    name = world
    if door ~= '' then
        name = name .. '|' ..door
    end
    if not bot:isInWorld(world:upper()) then
        local count = 0
        addEvent(Event.variantlist, function(variant, netid)
            if variant:get(0):getString() == 'OnConsoleMessage' then
                if variant:get(1):getString():lower():find('inaccessible.') or variant:get(1):getString():lower():find('unknown reason.') then
                    nuked = true
                end
                if variant:get(1):getString():lower():find('created too many worlds') or variant:get(1):getString():lower():find('unknown reason.') then
                    maxfind = true
                end
            end
        end)
        while not bot:isInWorld(world:upper()) and not nuked and not maxfind do
            if bot.status ~= BotStatus.online then
                customizable.textInfo('','status is '..customizable.initBot()..'')
                while bot.status ~= BotStatus.online do
                    bot:connect()
                    if bot.status == BotStatus.account_banned then
                        customizable.textInfo('stop','status is '..customizable.initBot()..'')
                    else
                        if bot.status == BotStatus.maintenance then
                            sleep(delaymaintenance * 60000)
                        else
                            sleep(delayreconnect * 1000)
                        end
                    end
                end
                customizable.textInfo('','status is '..customizable.initBot()..'')
            end
            bot:warp(name)
            listenEvents(4)
            sleep(delaywarp * 1000)
            count = count + 1
            if count == 5 then
                count = 0
                customizable.textInfo('',': Maybe hard warp?, disconnecting bot and sleeping for '..delayidiotserver..' minutes')
                bot:disconnect()
                sleep(delayidiotserver * 60000)
            end
        end
        removeEvents()
        sleep(1000)
    end
    if bot:isInWorld(world:upper()) and door ~= '' then
        local stuck  = 0
        while getTile(bot.x,bot.y).fg == 6 and not wrong do
            if bot.status == BotStatus.online and bot:getPing() == 0 then
                bot:disconnect()
                sleep(2000)
            end
            if bot.status ~= BotStatus.online then
                customizable.textInfo('','status is '..customizable.initBot()..'')
                while bot.status ~= BotStatus.online do
                    bot:connect()
                    if bot.status == BotStatus.account_banned then
                        customizable.textInfo('stop','status is '..customizable.initBot()..'')
                    else
                        if bot.status == BotStatus.maintenance then
                            sleep(delaymaintenance * 60000)
                        else
                            sleep(delayreconnect * 1000)
                        end
                    end
                end
                customizable.textInfo('','status is '..customizable.initBot()..'')
            end
            bot:warp(name)
            sleep(delaywarp * 1000)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

customizable.worldRandom = function()
    printed:append('Clearing history')
    customizable.localInfo('Clearing history')
    for _, value in pairs(worldclearhistory) do
        customizable.warp(value,'')
        if not maxfind then
            if not nuked then
                customizable.reconnect(value,'')
            else
                nuked = false
                customizable.textInfo('stop','World clearing history has nuked, Script terminated.')
            end
        else
            maxfind = false
            customizable.textInfo('stop','Too many creating worlds today, Script terminated.')
        end
    end
end

customizable.aboutHose = function(str,init,id)
    world, door = customizable.split(worldFireHouse[reversed],'[^|]+')[1], customizable.split(worldFireHouse[reversed],'[^|]+')[2]
    customizable.warp(world,door)
    if not nuked then
        if not wrong then
            if str == 'take' then
                if customizable.itemFloat(3066) > 0 then
                    for _, obj in pairs(getBot():getWorld():getObjects()) do
                        if obj.id == 3066 then
                            bot:findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                            sleep(100)
                            bot:collect(2)
                            sleep(1000)
                            customizable.reconnect(world,door,math.floor(obj.x / 32),math.floor(obj.y / 32))
                        end
                        if inventory:getItemCount(3066) > 0  then
                            break
                        end
                    end
                    if inventory:getItemCount(3066) > 0  then
                        bot:moveTo(1,0)
                        sleep(100)
                        bot:setDirection(true)
                        bot:wear(3066)
                        sleep(1000)
                        bot:drop(3066,inventory:getItemCount(3066) - 1)
                        sleep(1000)
                        customizable.reconnect(world,door,bot.x,bot.y)
                    end
                    customizable.warp(init,id)
                else
                    customizable.textInfo('','No more fire hose, Please drop right now!!, bot sleeping for 30 seconds.')
                    sleep(30000)
                end
            elseif str == 'drop' then
                while not bot:isInTile(customizable.jammerX,customizable.jammerY) do
                    bot:findPath(customizable.jammerX,customizable.jammerY)
                    customizable.reconnect(world,door,customizable.jammerX,customizable.jammerY)
                end
                while inventory:getItemCount(3066) > 0  do
                    bot:setDirection(true)
                    bot:drop(3066,200)
                    sleep(delaydrop * 1000)
                    customizable.reconnect(world,door,customizable.jammerX,customizable.jammerY)
                    if inventory:getItemCount(3066) > 0 then
                        bot:moveTo(1,0)
                        customizable.reconnect(world,door,customizable.jammerX,customizable.jammerY)
                    end
                end
                if inventory:getItemCount(98) > 0 then
                    bot:wear(98)
                    sleep(1000)
                end
                customizable.warp(init,id)
            end
        else
            wrong = false
            customizable.textInfo('stop','Id door world Fire house is wrong, Script terminated.')
        end
    else
        nuked = false
        customizable.textInfo('stop','world Fire house is Nuked, Script terminated.')
    end
end

customizable.wearingItem = function(init,item,amt,str)
    world, door = customizable.split(init[reversed],'[^|]+')[1], customizable.split(init[reversed],'[^|]+')[2]
    customizable.warp(world,door)
    if not nuked then
        if not wrong then
            if customizable.itemFloat(item) > 0 then
                for _, obj in pairs(getBot():getWorld():getObjects()) do
                    if obj.id == item then
                        bot:findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                        sleep(100)
                        bot:collect(2)
                        sleep(1000)
                        customizable.reconnect(world,door,math.floor(obj.x / 32),math.floor(obj.y / 32))
                    end
                    if inventory:getItemCount(item) > 0  then
                        break
                    end
                end
                if inventory:getItemCount(item) > 0  then
                    bot:moveTo(1,0)
                    sleep(100)
                    bot:setDirection(true)
                    bot:wear(item)
                    sleep(1000)
                    bot:drop(item,inventory:getItemCount(item) - amt)
                    sleep(1000)
                end
            else
                customizable.textInfo('','No more '..str..', please drop!, Bot sleeping for 30 seconds')
                sleep(30000)
            end
        else
            wrong = false
            customizable.textInfo('stop','Id door world '..str..' is wrong door, Script terminated.')
        end
    else
        nuked = false
        customizable.textInfo('stop','World '..str..' is nuked, Script terminated.')
    end
end

customizable.onEvent = function()
    printed:append('Dropping events')
    for i = customizable.indexEvents , #worldevent do
        world, door = customizable.split(worldevent[i],'[^|]+')[1], customizable.split(worldevent[i],'[^|]+')[2]
        customizable.warp(world,door)
        if not nuked then
            if not wrong then
                customizable.localInfo('Dropping Events')
                if customizable.itemFloat(eventList[1]) >= limitevent then
                    initialize[world] = customizable.itemFloat(eventList[1])..'x (LIMIT)'
                    customizable.textInfo('','Storage event : '..world..' has reached limit, skipped world')
                    customizable.indexEvents = customizable.indexEvents + 1
                    customizable.variableEvents = 0
                    if customizable.indexEvents > #worldevent then
                        initialize[world] = customizable.itemFloat(eventList[1])..'x (LIMIT)'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            customizable.warp(customizable.randomLetter(worldLetter),'')
                        end
                        customizable.localInfo('All events storage has reached limit')
                        customizable.textInfo('stop','All events storage has reached limit, Script terminated.')
                    end
                else
                    for y,pack in pairs(eventList) do
                        for i,tile in pairs(bot:getWorld():getTiles()) do
                            if tile.fg == 0 or tile.bg == 0 then
                                ::BACK::
                                bot:findPath(customizable.eventsX + (customizable.variableEvents),customizable.eventsY)
                                sleep(100)
                                local count = 0
                                customizable.reconnect(world,door,customizable.eventsX + (customizable.variableEvents),customizable.eventsY)
                                if customizable.eventsX + (customizable.variableEvents) >= 98 then
                                    customizable.eventsY = customizable.eventsY - 1
                                    customizable.variableEvents = 0
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(false)
                                    bot:drop(pack,200)
                                    sleep(delaydrop * 1000)
                                    customizable.reconnect(world,door,customizable.eventsX + (customizable.variableEvents),customizable.eventsY)
                                    count = count + 1
                                    if count >= 2 then
                                        customizable.variableEvents = customizable.variableEvents + 1
                                        goto BACK
                                    end
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                customizable.textInfo('','Storage event : '..world..' are wrong door id, Skipped world.')
                customizable.indexEvents = customizable.indexEvents + 1
                customizable.variableEvents = 0
                if customizable.indexEvents > #worldevent then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        customizable.warp(customizable.randomLetter(worldLetter),'')
                    end
                    customizable.localInfo('All events storage has reached limit')
                    customizable.textInfo('stop','All events storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            customizable.textInfo('','Storage event : '..world..' are Nuked, Skipped world.')
            customizable.indexEvents = customizable.indexEvents + 1
            customizable.variableEvents = 0
            if customizable.indexEvents > #worldevent then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    customizable.warp(customizable.randomLetter(worldLetter),'')
                end
                customizable.localInfo('All events storage has reached limit')
                customizable.textInfo('stop','All events storage has reached limit')
            end
        end 
    end
    initialize[world] = customizable.itemFloat(eventList[1])..'x'
    if clearhistory then
        customizable.worldRandom()
    end
end

customizable.onPack = function()
    printed:append('Dropping packs')
    for i = customizable.indexPacks , #worldpack do
        world, door = customizable.split(worldpack[i],'[^|]+')[1], customizable.split(worldpack[i],'[^|]+')[2]
        customizable.warp(world,door)
        if not nuked then
            if not wrong then
                customizable.localInfo('Dropping packs')
                if customizable.itemFloat(packList[1]) >= limitpack then
                    initialize[world] = customizable.itemFloat(packList[1])..'x (LIMIT)'
                    customizable.textInfo('','Storage packs : '..world..' has reached limit, skipped world')
                    customizable.indexPacks = customizable.indexPacks + 1
                    customizable.variablePacks = 0
                    if customizable.indexPacks > #worldpack then
                        initialize[world] = customizable.itemFloat(packList[1])..'x (LIMIT)'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            customizable.warp(customizable.randomLetter(worldLetter),'')
                        end
                        customizable.localInfo('All packs storage has reached limit')
                        customizable.textInfo('stop','All packs storage has reached limit')
                    end
                else
                    for y,pack in pairs(packList) do
                        for i,tile in pairs(bot:getWorld():getTiles()) do
                            if tile.fg == 0 or tile.bg == 0 then
                                ::BACK::
                                bot:findPath(customizable.packsX + (customizable.variablePacks),customizable.packsY)
                                sleep(100)
                                local count = 0
                                customizable.reconnect(world,door,customizable.packsX + (customizable.variablePacks),customizable.packsY)
                                if customizable.packsX + (customizable.variablePacks) >= 98 then
                                    customizable.packsY = customizable.packsY - 1
                                    customizable.variablePacks = 0
                                end
                                while inventory:getItemCount(pack) > 0 do
                                    bot:setDirection(false)
                                    bot:drop(pack,200)
                                    sleep(delaydrop * 1000)
                                    customizable.reconnect(world,door,customizable.packsX + (customizable.variablePacks),customizable.packsY)
                                    count = count + 1
                                    if count >= 2 then
                                        customizable.variablePacks = customizable.variablePacks + 1
                                        goto BACK
                                    end
                                end
                            end
                            if inventory:getItemCount(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                customizable.textInfo('','Storage packs : '..world..' are wrong door id, Skipped world.')
                customizable.indexPacks = customizable.indexPacks + 1
                customizable.variablePacks = 0
                if customizable.indexPacks > #worldpack then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        customizable.warp(customizable.randomLetter(worldLetter),'')
                    end
                    customizable.localInfo('All packs storage has reached limit')
                    customizable.textInfo('stop','All packs storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            customizable.textInfo('','Storage packs : '..world..' are Nuked, Skipped world.')
            customizable.indexPacks = customizable.indexPacks + 1
            customizable.variablePacks = 0
            if customizable.indexPacks > #worldpack then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    customizable.warp(customizable.randomLetter(worldLetter),'')
                end
                customizable.localInfo('All packs storage has reached limit')
                customizable.textInfo('stop','All packs storage has reached limit')
            end
        end 
    end
    initialize[world] = customizable.itemFloat(packList[1])..'x'
    if clearhistory then
        customizable.worldRandom()
    end
end

customizable.onSeed = function(seedid)
    printed:append('Dropping seeds')
    for i = customizable.indexSeeds , #worldseed do
        world = customizable.split(worldseed[i],'[^|]+')[1]
        door = customizable.split(worldseed[i],'[^|]+')[2]
        customizable.warp(world,door)
        if not nuked then
            if not wrong then
                customizable.localInfo('Dropping seeds')
                if customizable.itemFloat(pointData) >= limitseed then
                    initialize[world] = customizable.itemFloat(pointData)..'x (LIMIT)'
                    customizable.textInfo('','Storage seeds : '..world..' has reached limit, skipped world')
                    customizable.indexSeeds = customizable.indexSeeds + 1
                    customizable.variableSeeds = 0
                    if customizable.indexSeeds > #worldseed then
                        initialize[world] = customizable.itemFloat(pointData)..'x (LIMIT)'
                        if removingbot then
                            removeBot()
                            sleep(2000)
                        else
                            customizable.warp(customizable.randomLetter(worldLetter),'')
                        end
                        customizable.localInfo('All seeds storage has reached limit')
                        customizable.textInfo('stop','All seeds storage has reached limit')
                    end
                else
                    for i,tile in pairs(bot:getWorld():getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            bot:findPath(customizable.seedsX + (customizable.variableSeeds),customizable.seedsY)
                            sleep(100)
                            local count = 0
                            customizable.reconnect(world,door,customizable.seedsX + (customizable.variableSeeds),customizable.seedsY)
                            if customizable.seedsX + (customizable.variableSeeds) >= 98 then
                                customizable.seedsY = customizable.seedsY - 1
                                customizable.variableSeeds = 0
                            end
                            while inventory:getItemCount(seedid) > 0 do
                                bot:setDirection(false)
                                bot:drop(seedid,200)
                                sleep(delaydrop * 1000)
                                customizable.reconnect(world,door,customizable.seedsX + (customizable.variableSeeds),customizable.seedsY)
                                count = count + 1
                                if count >= 2 then
                                    customizable.variableSeeds = customizable.variableSeeds + 1
                                    goto BACK
                                end
                            end
                        end
                        if inventory:getItemCount(seedid) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                initialize[world] = 'WRONG DOOR'
                wrong = false
                customizable.textInfo('','Storage seeds : '..world..' are wrong door id, Skipped world.')
                customizable.indexSeeds = customizable.indexSeeds + 1
                customizable.variableSeeds = 0
                if customizable.indexSeeds > #worldseed then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    else
                        customizable.warp(customizable.randomLetter(worldLetter),'')
                    end
                    customizable.localInfo('All seeds storage has reached limit')
                    customizable.textInfo('stop','All seeds storage has reached limit')
                end
            end
        else
            initialize[world] = 'NUKED'
            nuked = false
            customizable.textInfo('','Storage seeds : '..world..' are Nuked, Skipped world.')
            customizable.indexSeeds = customizable.indexSeeds + 1
            customizable.variableSeeds = 0
            if customizable.indexSeeds > #worldseed then
                if removingbot then
                    removeBot()
                    sleep(2000)
                else
                    customizable.warp(customizable.randomLetter(worldLetter),'')
                end
                customizable.localInfo('All seeds storage has reached limit')
                customizable.textInfo('stop','All seeds storage has reached limit')
            end
        end 
    end
    initialize[world] = customizable.itemFloat(pointData)..'x'
    if clearhistory then
        customizable.worldRandom()
    end
end

customizable.onBackup = function()
    printed:append('Bot : '..bot.name..' reached max level, switching bot')
    ::BACK::
    for idx = customizable.indexBackups, #onBotBackup do
        thread, threading = customizable.split(onBotBackup[idx],'([^|]+)')[1], customizable.split(onBotBackup[idx],'([^|]+)')[2]
        if typeaccount == 'normal' then
            bot:updateBot(thread,threading)
        elseif typeaccount == 'guest' then
            bot:updateBot(customizable.randomLetter(letter)..'',thread,threading)
        end
        sleep(delayloginbot * 1000)
        bot.auto_reconnect = false
        customizable.textInfo('','Succes switching bot to > '..bot.name..'')
        while bot.status ~= BotStatus.online do
            bot:connect()
            if bot.status == BotStatus.account_banned then
                initialize[thread] = 'Suspended'
                customizable.writeFile('switchStatus',thread..' : status is Suspended')
                customizable.textInfo('','Bot : '..thread..' is suspended, skipped bot')
                customizable.indexBackups = customizable.indexBackups + 1
                if customizable.indexBackups > #onBotBackup then
                    if removingbot then
                        removeBot()
                        sleep(2000)
                    end
                    customizable.localInfo('No more bots to switch')
                    customizable.textInfo('stop','No more bots to switch, sc terminated')
                end
                goto BACK
            else
                sleep(delayreconnect * 1000)
            end
        end
        if bot.status == BotStatus.online and bot.level < switchOnLevel then
            initialize[thread] = 'Used'
            break
        elseif bot.status == BotStatus.online and bot.level >= switchOnLevel then
            initialize[thread] = 'Reached max level'
            customizable.indexBackups = customizable.indexBackups + 1
            if customizable.indexBackups > #onBotBackup then
                if removingbot then
                    removeBot()
                    sleep(2000)
                end
                customizable.textInfo('stop','No more bots to switch, sc terminated')
            end
            goto BACK
        end
    end
end

customizable.onPnb = function(str,info,door,item)
    ::BACK::
    if not pnbother then
        botX = 98
        botY = bot.y
        if botY > 40 then
            botY = botY - 10
        elseif botY < 11 then
            botY = botY + 10
        end
        if getTile(botX,botY).fg ~= 0 and getTile(botX,botY).fg ~= item+1 then
            botY = botY - 1
        end
        customizable.customPnb(info,door,item,botX,botY)
    else
        if pnbOnTutorial then
            ::enet::
            for i, val in pairs(tutorial) do
                local detect = customizable.split(worldJammer[reversed],'[^|]+')[1]
                customizable.warp(val,'')
                if not nuked then
                    customizable.customPnb(val,'',item,customizable.positionX,customizable.positionY)
                else
                    nuked = false
                    table.remove(tutorial,i)
                    if detect ~= 'x' then
                        customizable.textInfo('','World PNB : '..val..' is NUKED, Creating a new world again')
                        while inventory:getItemCount(226) == 0 do
                            customizable.aboutJammer('take')
                        end
                        customizable.createWorld('tutorial')
                        goto enet
                    else
                        customizable.textInfo('stop','World PNB : '..val..' is NUKED, Script terminated.')
                    end
                end
            end
        else
            if useCustomPnb then
                for i = customizable.changeWorld, #indexPnb do
                    local world = customizable.split(indexPnb[i],'[^|]+')[1]
                    local static = customizable.split(indexPnb[i],'[^|]+')[2]
                    customizable.warp(world,static)
                    if not nuked then
                        if not wrong then
                            customizable.customPnb(world,static,item,customizable.positionX,customizable.positionY)
                        else
                            wrong = false
                            customizable.changeWorld = customizable.changeWorld + 1
                            table.remove(indexPnb,i)
                            customizable.textInfo('','World PNB : '..world..' is Wrong, skipped world')
                            goto BACK
                        end
                    else
                        nuked = false
                        if #indexPnb == 1 then
                            customizable.textInfo('stop','World PNB : '..world..' is NUKED!, Script terminated.')
                        else
                            customizable.textInfo('','World PNB : '..world..' is NUKED, skipped world')
                            customizable.changeWorld = customizable.changeWorld + 1
                            if customizable.changeWorld > #indexPnb then
                                customizable.changeWorld = 1
                            end
                            table.remove(indexPnb,i)
                            goto BACK
                        end
                    end
                    if #indexPnb > 1 then
                        customizable.changeWorld = customizable.changeWorld + 1
                        if customizable.changeWorld > #indexPnb then
                            customizable.changeWorld = 1
                        end
                    end
                    break
                end
            else
                ::link::
                for i = customizable.indexCreating, #initFreshWorld do
                    customizable.warp(initFreshWorld[i],'')
                    if not nuked then
                        customizable.customPnb(initFreshWorld[i],'',item,customizable.positionX,customizable.positionY)
                    else
                        table.remove(initFreshWorld,i)
                        customizable.textInfo('','World PNB : '..initFreshWorld[i]..' is NUKED, Creating a new world again')
                        nuked = false
                        while inventory:getItemCount(226) == 0 do
                            customizable.aboutJammer('take')
                        end
                        customizable.createWorld('for pnb')
                        goto link              
                    end
                end
            end
        end
    end
end

customizable.recheckWorld = function(str,info,static,item,log)
    tileA, tileB, tileC, tileD = 99, 0, -1, 0
    printed:append(log)
    customizable.localInfo(log)
    bot.auto_collect = true
    if str ~= 'leveling' then 
        for y = -1, 53 do
            for x = tileA, tileB, tileC do
                if customizable.isHarvested(x,y,item+1) then
                    while not bot:isInTile(x,y) do
                        bot:findPath(x,y)
                        customizable.reconnect(info,static,x,y)
                    end
                    for i = 1, 5 do
                        if getTile(x,y).fg == item+1 and getTile(x,y):canHarvest() then
                            bot:hit(x,y)
                            sleep(delayharvest)
                            customizable.reconnect(info,static,x,y)
                        else
                            break
                        end
                    end
                end
                customizable.detectInventory(str,info,static,item,log)
            end
        end
    end
    for _, obj in pairs(getBot():getWorld():getObjects()) do
        if obj.id == item then
            bot:findPath(math.floor((obj.x + 10) / 32),math.floor((obj.y + 10) / 32))
            sleep(30)
            customizable.reconnect(info,static,math.floor((obj.x + 10) / 32),math.floor((obj.y + 10) / 32))
        end
        customizable.detectInventory(str,info,static,item,log)
    end
    if not dontplant and str ~= 'leveling' then
        bot.auto_collect = false
        customizable.detectPlant(info,static,item+1)
        if inventory:getItemCount(item+1) >= amountseed / 2 then
            customizable.onSeed(item+1)
            printed:append(log)
            customizable.warp(info,static)
            customizable.localInfo(log)
            bot.auto_collect = true
        end
    end
end

customizable.harvest = function(str,info,static,item,log)
    tileA, tileB, tileC = 99, 0, -1
    printed:append(log)
    bot.auto_collect = true
    customizable.localInfo(log)
    for val = 2,3 do
        for y = val, 53, increment do
            for x = tileA, tileB, tileC do
                if customizable.isHarvested(x,y,item+1) and x >= 3 then
                    while not bot:isInTile(x-2,y) do
                        bot:findPath(x-2,y)
                        customizable.reconnect(info,static,x-2,y)
                    end
                    customizable.pattern('harvest',info,static,item+1)
                end
                if bot.level >= setmaxlvl and leveling and str == 'leveling' then
                    break
                end
                customizable.detectInventory(str,info,static,item,log)
            end
        end
    end
end

customizable.plant = function(info,static,seedid)
    tileA, tileB, tileC = 99, 0, -1
    printed:append('Planting')
    customizable.localInfo('Planting')
    for val = 2,3 do
        for y = val , 53, increment do
            for x = tileA, tileB, tileC do
                if getTile(x, y).fg == 0 and getTile(x, y + 1).fg ~= 0 and x >= 3 then
                    if inventory:getItemCount(seedid) <= 15 then
                        break
                    end
                    bot:findPath(x-2,y)
                    customizable.reconnect(info,static,x-2,y)
                    if bot:isInTile(x-2,y) then
                        customizable.pattern('plant',info,static,seedid)
                    end
                end
            end
        end
    end
end

customizable.botOnLeveling = function()
    for i = customizable.indexLeveling, #onLeveling do
        value = onLeveling[i]
        local world = customizable.split(value,'[^|]+')[1]
        local door = customizable.split(value,'[^|]+')[2]
        customizable.warp(world,door)
        if not nuked then
            if not wrong then
                if clearToxic and customizable.scanningTile(778) then
                    customizable.textInfo('','There are '..customizable.scanBlock(778)..'x toxic waste, bot clearing first before rotation')
                    customizable.localInfo('Clearing waste')
                    customizable.cleaning('toxic',world,door)
                end
                if clearFire and customizable.scanningFlags(4096) then
                    customizable.textInfo('','There are '..customizable.flagsCheck(4096)..'x fire, bot clearing first before rotation')
                    if inventory:getItemCount(3066) == 0 then
                        bot.auto_collect = false
                        printed:append('Taking fire hose')
                        customizable.localInfo('Taking fire hose')
                        while inventory:getItemCount(3066) == 0 do
                            customizable.aboutHose('take',world,door)
                        end
                    end
                    customizable.localInfo('Clearing fire')
                    customizable.cleaning('burn',world,door)
                end
                while inventory:getItemCount(98) > 0 and not inventory:getItem(98).isActive do
                    bot:wear(98)
                    sleep(1000)
                end
                customizable.localInfo('Leveling')
                customizable.harvest('leveling',world,door,idblockleveling,'Harvesting(leveling)')
                for i = 1 , recheckingCount do
                    customizable.recheckWorld('leveling',world,door,idblockleveling,'Rechecking(leveling)')
                end
                if bot.level >= setmaxlvl then
                    customizable.textInfo('','Bot reached max leveling, now doing rotation!')
                    break
                end
            else
                customizable.indexLeveling = customizable.indexLeveling + 1
                wrong = false
                customizable.textInfo('','World leveling : '..world..' is wrong door id, skipped world')
            end
        else
            customizable.indexLeveling = customizable.indexLeveling + 1
            nuked = false
            customizable.textInfo('','World leveling : '..world..' is NUKED, Skipped world.')
        end
    end
    if bot.level < setmaxlvl then
        customizable.textInfo('stop','No more trees on world leveling, please input more worlds')
    end
end

customizable.harvestOnTutorial = function(tree,amount,world)
    local attempt = 0
    for _,tile in pairs(bot:getWorld():getTiles()) do
        if tile.fg == tree then
            bot:findPath(tile.x,tile.y)
            sleep(30)
            customizable.reconnect(world,'',tile.x,tile.y)
            while bot:getWorld():getTile(tile.x,tile.y).fg ~= 0 do
                bot:hit(tile.x,tile.y)
                sleep(200)
                customizable.reconnect(world,'',tile.x,tile.y)
            end
            attempt = attempt + 1
        end
        if attempt >= amount then
            break
        end
    end
end
customizable.placeDirtOnTutorial = function(world)
    for tilex = 35, 50 do
        bot:findPath(tilex,17)
        sleep(30)
        customizable.reconnect(world,'',tilex,17)
        while bot:getWorld():getTile(tilex,18).fg == 0 do
            bot:place(tilex,18,2)
            sleep(200)
            customizable.reconnect(world,'',tilex,17)
        end
    end
end
customizable.breakDirtOnTutorial = function(amount,world)
    local attempt = 0
    for tiley = 19, 53, 1 do
        for tilex = 0, 6, 1 do
            if bot:getWorld():getTile(tilex,tiley).fg == 2 then
                bot:findPath(tilex,tiley - 1)
                sleep(30)
                customizable.reconnect(world,'',tilex,tiley - 1)
                while bot:getWorld():getTile(tilex,tiley).fg ~= 0 do
                    bot:hit(tilex,tiley)
                    sleep(200)
                    customizable.reconnect(world,'',tilex,tiley - 1)
                end
                attempt = attempt + 1
            end
            if attempt >= amount then
                break
            end
        end
        if attempt >= amount then
            break
        end
    end
end
customizable.searchDirt = function(amount,world)
    for tiley = 19, 53, 1 do
        for tilex = 0, 6, 1 do
            if bot:getWorld():getTile(tilex,tiley).fg ~= 0 then
                bot:findPath(tilex,tiley - 1)
                sleep(30)
                customizable.reconnect(world,'',tilex,tiley - 1)
                while bot:getWorld():getTile(tilex,tiley).fg ~= 0 do
                    bot:hit(tilex,tiley)
                    sleep(200)
                    customizable.reconnect(world,'',tilex,tiley - 1)
                end
            end
            if inventory:getItemCount(3) >= amount then
                break
            end
        end
        if inventory:getItemCount(3) >= amount then
            break
        end
    end
end

customizable.placingWood = function(world)
    for tilex = 35, 56 do
        bot:findPath(tilex,14)
        sleep(30)
        customizable.reconnect(world,'',tilex,14)
        while bot:getWorld():getTile(tilex,15).fg == 0 do
            bot:place(tilex,15,100)
            sleep(200)
            customizable.reconnect(world,'',tilex,14)
        end
    end
end
customizable.breakWood = function(world)
    for tilex = 35, 56 do
        bot:findPath(tilex,14)
        sleep(30)
        customizable.reconnect(world,'',tilex,14)
        while bot:getWorld():getTile(tilex,15).fg ~= 0 do
            bot:hit(tilex,15)
            sleep(200)
            customizable.reconnect(world,'',tilex,14)
        end
        if inventory:getItemCount(101) > 4 then
            break
        end
    end
end
customizable.plantOnTutorial = function(tree,amount,world)
    local attempt = 0
    for tilex = 35, 50 do
        if bot:getWorld():getTile(tilex,17).fg == 0 then
            bot:findPath(tilex,17)
            sleep(30)
            customizable.reconnect(world,'',tilex,17)
            while bot:getWorld():getTile(tilex,17).fg == 0 do
                bot:place(tilex,17,tree)
                sleep(200)
                customizable.reconnect(world,'',tilex,17)
            end
            attempt = attempt + 1
        end
        if attempt >= amount then
            break
        end
    end
end
customizable.reduceTree = function(tree,world)
    local attempt = 0
    for tilex = 35, 50 do
        if bot:getWorld():getTile(tilex,17).fg ~= 0 then
            bot:findPath(tilex,17)
            sleep(30)
            customizable.reconnect(world,'',tilex,17)
            while bot:getWorld():getTile(tilex,17).fg ~= 0 do
                bot:hit(tilex,17)
                sleep(200)
                customizable.reconnect(world,'',tilex,17)
            end
            attempt = attempt + 1
        end
        if attempt >= 10 then
            break
        end
    end
end
customizable.spliceOnTutorial = function(item1,item2,amount,world)
    local attempt = 0
    for tilex = 35, 45 do
        if bot:getWorld():getTile(tilex,17).fg == 0 then
            bot:findPath(tilex,17)
            sleep(30)
            customizable.reconnect(world,'',tilex,17)
            while bot:getWorld():getTile(tilex,17).fg == 0 do
                bot:place(tilex,17,item1)
                sleep(200)
                customizable.reconnect(world,'',tilex,17)
            end
            while bot:getWorld():getTile(tilex,17).fg == item1 do
                bot:place(tilex,17,item2)
                sleep(200)
                customizable.reconnect(param,'',tilex,17)
            end
            attempt = attempt + 1
        end
        if attempt >= amount then
            break
        end
    end
end
customizable.breakBlock = function(id,target,world)
    for _, obj in pairs(getBot():getWorld():getObjects()) do
        if obj.id == id then
            bot:findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
            sleep(1000)
            customizable.reconnect(world,'',bot.x,bot.y)
        end
    end
    while inventory:getItemCount(id+1) < target do
        while bot:getWorld():getTile(bot.x,bot.y-1).fg == 0 do
            bot:place(bot.x,bot.y-1,id)
            sleep(210)
            customizable.reconnect(world,'',bot.x,bot.y)
        end
        while bot:getWorld():getTile(bot.x,bot.y-1).fg ~= 0 do
            bot:hit(bot.x,bot.y-1)
            sleep(210)
            customizable.reconnect(world,'',bot.x,bot.y)
        end
        sleep(500)
    end
end

customizable.skippingQuest = function(val)
    bot.auto_collect = true
    customizable.localInfo('Skipping tutorial')
    for _, tile in pairs(bot:getWorld():getTiles()) do
        if tile.fg == 11 and tile:canHarvest() then
            customizable.harvestOnTutorial(3,5,val)
            sleep(200)
            customizable.placeDirtOnTutorial(val)
            sleep(200)
            customizable.breakDirtOnTutorial(20,val)
            sleep(200)
            customizable.searchDirt(11,val)
            customizable.plantOnTutorial(3,10,val)
            sleep(31000)
            customizable.reduceTree(3,val)
            sleep(200)
            customizable.harvestOnTutorial(11,10,val)
            sleep(200)
            for i = 1,5 do
                bot:drop(11,200)
                sleep(2000)
                customizable.reconnect(val,'',bot.x,bot.y)
            end
            sleep(200)
            customizable.harvestOnTutorial(5,9,val)
            sleep(200)
            customizable.breakBlock(4,10,val)
            sleep(200)
            customizable.searchDirt(12,val)
            sleep(200)
            customizable.spliceOnTutorial(3,5,10,val)
            sleep(68000)
            customizable.reduceTree(101,val)
            sleep(200)
            customizable.placingWood(val)
            sleep(200)
            customizable.breakWood(val)
            sleep(200)
            customizable.spliceOnTutorial(101,3,1,val)
            sleep(122000)
            bot:hit(bot.x,bot.y)
            sleep(1000)
            customizable.reconnect(val,'',bot.x,bot.y)
        end
    end
    bot.auto_collect = false
end

customizable.autoPlantEnabled = function()
    for idx = customizable.indexPlant, #plantTable do
        local world = customizable.split(plantTable[idx],'[^|]+')[1]
        local doorWorlds = customizable.split(plantTable[idx],'[^|]+')[2]
        customizable.warp(world,doorWorlds)
        if not nuked then
            if not wrong then
                customizable.localInfo('Planting')
                customizable.plant(world,doorWorlds,pointData)
                customizable.detectPlant(world,doorWorlds,pointData)
                if inventory:getItemCount(pointData) <= 15 then
                    break
                else
                    customizable.indexPlant = customizable.indexPlant + 1
                end
            else
                wrong = false
                customizable.indexPlant = customizable.indexPlant + 1
                customizable.textInfo('','World auto plant : '..world..' is wrong door id, Skipped world.')
            end
        else
            nuked = false
            customizable.indexPlant = customizable.indexPlant + 1
            customizable.textInfo('','World auto plant : '..world..' is NUKED, Skipped world.')
        end
    end
    customizable.textInfo('stop','All world already planted, please disable auto plant then re-execute')
end

customizable.breakJammer = function()
    local function erased()
        local file = io.open('FreshWorld.txt','w+')
        file:close()
    end
    for i = customizable.indexFresh, #freshId do
        val = freshId[i]
        customizable.warp(val,'')
        if not nuked then
            while getTile(bot.x,bot.y-1).fg == 226 do
                bot:hit(bot.x,bot.y-1)
                sleep(200)
                customizable.reconnect(val,'')
            end
        else
            nuked = false
            customizable.indexFresh = customizable.indexFresh+1
            customizable.textInfo('',val..' World Take back jammer are nuked, Skipped world')
        end
    end
    while inventory:getItemCount(226) > 0 do
        bot.auto_collect = false
        customizable.aboutJammer('storing')
    end
    erased()
    customizable.textInfo('stop','Finished take back all jammer')
end

customizable.aboutJammer = function(str)
    world, door = customizable.split(worldJammer[reversed],'[^|]+')[1], customizable.split(worldJammer[reversed],'[^|]+')[2] 
    customizable.warp(world,door)
    if not nuked then
        if not wrong then
            bot.auto_collect = false
            if str == 'take' then
                if customizable.itemFloat(226) > 0 then
                    for _, obj in pairs(getBot():getWorld():getObjects()) do
                        if obj.id == 226 then
                            bot:findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                            sleep(100)
                            bot:collect(2)
                            sleep(1000)
                            customizable.reconnect(world,door,math.floor(obj.x / 32),math.floor(obj.y / 32))
                        end
                        if inventory:getItemCount(226) > 0  then
                            break
                        end
                    end
                    if inventory:getItemCount(226) > 0  then
                        bot:moveTo(1,0)
                        sleep(1000)
                        bot:setDirection(true)
                        bot:wear(226)
                        sleep(1000)
                        bot:drop(226,inventory:getItemCount(226) - 1)
                        sleep(1000)
                    end
                else
                    customizable.textInfo('','Jammer is empty, drop right now!, Bot sleeping for 30 seconds')
                    sleep(30000)
                end
            elseif str == 'storing' then
                while not bot:isInTile(customizable.jammerX,customizable.jammerY) do
                    bot:findPath(customizable.jammerX,customizable.jammerY)
                    sleep(300)
                    customizable.reconnect(world,door,customizable.jammerX,customizable.jammerY)
                end
                while inventory:getItemCount(226) > 0  do
                    bot:setDirection(true)
                    bot:drop(226,200)
                    sleep(delaydrop * 1000)
                    customizable.reconnect(world,door,customizable.jammerX,customizable.jammerY)
                    if inventory:getItemCount(226) > 0 then
                        bot:moveTo(1,0)
                        customizable.reconnect(world,door,customizable.jammerX,customizable.jammerY)
                    end
                end
            end
        else
            wrong = false
            customizable.textInfo('stop','Id door world jammer is wrong, check ur id door !, terminated script')
        end
    else
        nuked = false
        customizable.textInfo('stop','World jammer is nuked, check ur world !, terminated script')
    end
end

customizable.createWorld = function(str)
    ::back::
    initWorld = customizable.randomLetter(worldLetter)
    customizable.warp(initWorld,'')
    if not maxfind then
        if not nuked then
            if not customizable.tileDetect() then
                while getTile(bot.x,bot.y-1).fg ~= 226 do
                    bot:place(bot.x,bot.y-1,226)
                    sleep(200)
                    customizable.reconnect(initWorld,'')
                end
                sleep(1500)
                if getTile(bot.x,bot.y-1).fg == 226 then
                    bot:hit(bot.x,bot.y-1)
                    sleep(200)
                    customizable.reconnect(initWorld,'')
                end
                customizable.writeFile('FreshWorld',initWorld)
                if str == 'tutorial' then
                    table.insert(tutorial,initWorld)
                else
                    table.insert(initFreshWorld,initWorld)
                end
            else
                goto back
            end
        else
            nuked = false
            goto back
        end
    else
        maxfind = false
        customizable.textInfo('stop','Too many creating worlds today, Script terminated.')
    end
end

customizable.mainScript = function()
    while inventory:getItemCount(9640) > 0 do
        customizable.warp(customizable.randomLetter(worldLetter),'')
        if not maxfind then
            if not nuked then
                if not customizable.tileDetect() then
                    while getTile(bot.x,bot.y - 1).fg ~= 9640 do
                        bot:place(bot.x,bot.y - 1,9640)
                        sleep(delayplace)
                    end
                end
            else
                nuked = false
            end
        else
            maxfind = false
            customizable.textInfo('stop','Too many creating worlds today, Script terminated.')
        end
    end
    if takeBackJammer then
        customizable.breakJammer()
    end
    if autoSkipQuest or pnbOnTutorial then
        printed:append('Skipping tutorial')
        addEvent(Event.variantlist, customizable.hookOnTutorial)
        runThread(function()
            getBot():sendPacket(2, 'action|wrench\n|netid|'..getLocal().netid)
            sleep(1000)
            getBot():sendPacket(2, 'action|dialog_return\ndialog_name|popup\nnetID|'..getLocal().netid..'|\nbuttonClicked|my_worlds')
            sleep(1000)
        end)    
        listenEvents(delaywarp)
        if autoSkipQuest then
            for _, val in ipairs(tutorial) do
                customizable.warp(val,'')
                if not nuked then
                    customizable.skippingQuest(val)
                else
                    nuked = false
                    customizable.textInfo('','World tutorial is nuked, Failed to skipping tutorial')
                end
            end
        end
    end
    if wearPickaxe then
        if inventory:getItemCount(98) == 0 and bot.status == BotStatus.online then
            printed:append('Take pickaxe')
            customizable.localInfo('Take pickaxe')
            while inventory:getItemCount(98) == 0 do
                customizable.wearingItem(worldpickaxe,98,1,'pickaxe')
            end
        end
    end
    if pnbother and useFreshPnb then
        if inventory:getItemCount(226) == 0 then
            printed:append('Take jammer')
            customizable.localInfo('Take jammer')
            bot.auto_collect = false
            while inventory:getItemCount(226) == 0 do
                customizable.aboutJammer('take')
            end
        end
        customizable.createWorld('for pnb')
    end
    if leveling and bot.level < setmaxlvl then
        customizable.botOnLeveling()
    end
    while true do
        for idx , val in pairs(onFarmList) do
            local world = customizable.split(val,'[^|]+')[1]
            local doorWorld =  customizable.split(val,'[^|]+')[2]
            customizable.warp(world,doorWorld)
            if not nuked then
                if not wrong then
                    if clearToxic and customizable.scanningTile(778) then
                        customizable.textInfo('','There are '..customizable.scanBlock(778)..'x toxic waste, bot clearing first before rotation')
                        customizable.localInfo('Clearing waste')
                        customizable.cleaning('toxic',world,doorWorld)
                    end
                    if clearFire and customizable.scanningFlags(4096) then
                        customizable.textInfo('','There are '..customizable.flagsCheck(4096)..'x fire, bot clearing first before rotation')
                        if inventory:getItemCount(3066) == 0 then
                            bot.auto_collect = false
                            printed:append('Taking fire hose')
                            customizable.localInfo('Taking fire hose')
                            while inventory:getItemCount(3066) == 0 do
                                customizable.aboutHose('take',world,doorWorld)
                            end
                        end
                        customizable.localInfo('Clearing fire')
                        customizable.cleaning('burn',world,doorWorld)
                    end
                    while inventory:getItemCount(98) > 0 and not inventory:getItem(98).isActive do
                        bot:wear(98)
                        sleep(1000)
                    end
                    customizable.localInfo('Harvesting')
                    formattedTime = os.time()
                    customizable.harvest('harvest',val,doorWorld,block,'Harvesting')
                    for i = 1, recheckingCount do
                        customizable.recheckWorld('harvest',val,doorWorld,block,'Rechecking')
                    end
                    formattedTime = os.time() - formattedTime
                    customizable.tableFormatted(string.sub(world,1,3)..' | '..math.floor(formattedTime/3600)..' Hours '..math.floor(formattedTime%3600/60)..' Mins')
                    if clearhistoryAfterdoneFarm then
                        customizable.worldRandom()
                    end
                    if restAfterDoneFarm then
                        printed:append('Resting after farm')
                        bot:leaveWorld()
                        sleep(delayRestAfterDoneFarm * 60000)
                    end
                else
                    wrong = false
                    customizable.tableFormatted(string.sub(world,1,3)..' | Wrong')
                    customizable.textInfo('',world..' : is wrong door id, skipped world')
                end
            else
                nuked = false
                customizable.tableFormatted(string.sub(world,1,3)..' | Nuked')
                customizable.textInfo('',world..' : is NUKED!, Skipped world.')
            end
        end
        if not looping then
            if inventory:getItemCount(pointData) > 0 then
                customizable.onSeed(pointData)
            end
            customizable.warp(customizable.randomLetter(worldLetter),'')
            if removingbot then
                removeBot()
                sleep(1500)
            else
                customizable.warp(customizable.randomLetter(worldLetter),'')
            end
            customizable.localInfo('Already finished all world')
            customizable.textInfo('stop','Already finished all world')
            break
        else
            sleep(5000)
        end
    end
end

if Information == 'Script Rotation made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq' and scriptVersion == '0.5' then
    customizable.setAuth()
    sleep(pcallBot * delayexecute * 1000)
    customizable.mainScript()
else
    customizable.textInfo('stop','Script Rotation made by Caramoy Syndicate, Link Discord : https://discord.com/invite/fTTKW8vvuq, Reseller IDIOT !!')
end
